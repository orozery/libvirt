From 04bd77a19f8312493151ce377da40577b1470a0b Mon Sep 17 00:00:00 2001
Description: conf: Move and rename virDomainParseScaledValue()
Author: Michal Privoznik <mprivozn@redhat.com>
Origin: backport, https://github.com/libvirt/libvirt/commit/04bd77a19f8312493151ce377da40577b1470a0b
Bug: https://gitlab.com/libvirt/libvirt/-/issues/154
Reviewed-by: Rafael David Tinoco <rafaeldtinoco@ubuntu.com>
Last-Update: 2021-05-24

conf: Move and rename virDomainParseScaledValue()

There is nothing domain specific about the function, thus it
should not have virDomain prefix. Also, the fact that it is a
static function makes it impossible to use from other files.
Move the function to virxml.c and drop the 'Domain' infix.

[Backport]
  This commit renames, relocates and declares a function without
  changing its logic: makes cherry-picking the feature "QCOW2
  cluster_size option" fast forward without changing its logic.

Signed-off-by: Michal Privoznik <mprivozn@redhat.com>
Reviewed-by: Daniel Henrique Barboza <danielhb413@gmail.com>
Signed-off-by: Rafael David Tinoco <rafaeldtinoco@ubuntu.com>
---
 src/conf/domain_conf.c   | 135 ++++++++++-----------------------------
 src/libvirt_private.syms |   1 +
 src/util/virxml.c        |  72 +++++++++++++++++++++
 src/util/virxml.h        |   8 +++
 4 files changed, 114 insertions(+), 102 deletions(-)

--- a/src/conf/domain_conf.c
+++ b/src/conf/domain_conf.c
@@ -10474,75 +10474,6 @@
     goto cleanup;
 }
 
-/**
- * virDomainParseScaledValue:
- * @xpath: XPath to memory amount
- * @units_xpath: XPath to units attribute
- * @ctxt: XPath context
- * @val: scaled value is stored here
- * @scale: default scale for @val
- * @max: maximal @val allowed
- * @required: is the value required?
- *
- * Parse a value located at @xpath within @ctxt, and store the
- * result into @val. The value is scaled by units located at
- * @units_xpath (or the 'unit' attribute under @xpath if
- * @units_xpath is NULL). If units are not present, the default
- * @scale is used. If @required is set, then the value must
- * exist; otherwise, the value is optional. The resulting value
- * is in bytes.
- *
- * Returns 1 on success,
- *         0 if the value was not present and !@required,
- *         -1 on failure after issuing error.
- */
-static int
-virDomainParseScaledValue(const char *xpath,
-                          const char *units_xpath,
-                          xmlXPathContextPtr ctxt,
-                          unsigned long long *val,
-                          unsigned long long scale,
-                          unsigned long long max,
-                          bool required)
-{
-    unsigned long long bytes;
-    g_autofree char *xpath_full = NULL;
-    g_autofree char *unit = NULL;
-    g_autofree char *bytes_str = NULL;
-
-    *val = 0;
-    xpath_full = g_strdup_printf("string(%s)", xpath);
-
-    bytes_str = virXPathString(xpath_full, ctxt);
-    if (!bytes_str) {
-        if (!required)
-            return 0;
-        virReportError(VIR_ERR_XML_ERROR,
-                       _("missing element or attribute '%s'"),
-                       xpath);
-        return -1;
-    }
-    VIR_FREE(xpath_full);
-
-    if (virStrToLong_ullp(bytes_str, NULL, 10, &bytes) < 0) {
-        virReportError(VIR_ERR_XML_ERROR,
-                       _("Invalid value '%s' for element or attribute '%s'"),
-                       bytes_str, xpath);
-        return -1;
-    }
-
-    if (units_xpath)
-         xpath_full = g_strdup_printf("string(%s)", units_xpath);
-    else
-         xpath_full = g_strdup_printf("string(%s/@unit)", xpath);
-    unit = virXPathString(xpath_full, ctxt);
-
-    if (virScaleInteger(&bytes, unit, scale, max) < 0)
-        return -1;
-
-    *val = bytes;
-    return 1;
-}
 
 
 /**
@@ -10579,8 +10510,8 @@
 
     max = virMemoryMaxValue(capped);
 
-    if (virDomainParseScaledValue(xpath, units_xpath, ctxt,
-                                  &bytes, 1024, max, required) < 0)
+    if (virParseScaledValue(xpath, units_xpath, ctxt,
+                            &bytes, 1024, max, required) < 0)
         return -1;
 
     /* Yes, we really do use kibibytes for our internal sizing.  */
@@ -10622,9 +10553,9 @@
     int ret;
     unsigned long long bytes;
 
-    ret = virDomainParseScaledValue(xpath, units_xpath, ctxt, &bytes, 1024,
-                                    VIR_DOMAIN_MEMORY_PARAM_UNLIMITED << 10,
-                                    false);
+    ret = virParseScaledValue(xpath, units_xpath, ctxt, &bytes, 1024,
+                              VIR_DOMAIN_MEMORY_PARAM_UNLIMITED << 10,
+                              false);
 
     if (ret < 0)
         return -1;
@@ -10953,9 +10884,9 @@
                                  "have an address"));
                 goto error;
             }
-            if ((rc = virDomainParseScaledValue("./pcihole64", NULL,
-                                                ctxt, &bytes, 1024,
-                                                1024ULL * ULONG_MAX, false)) < 0)
+            if ((rc = virParseScaledValue("./pcihole64", NULL,
+                                          ctxt, &bytes, 1024,
+                                          1024ULL * ULONG_MAX, false)) < 0)
                 goto error;
 
             if (rc == 1)
@@ -11166,14 +11097,14 @@
         }
     }
 
-    if (virDomainParseScaledValue("./space_hard_limit[1]",
-                                  NULL, ctxt, &def->space_hard_limit,
-                                  1, ULLONG_MAX, false) < 0)
+    if (virParseScaledValue("./space_hard_limit[1]",
+                            NULL, ctxt, &def->space_hard_limit,
+                            1, ULLONG_MAX, false) < 0)
         goto error;
 
-    if (virDomainParseScaledValue("./space_soft_limit[1]",
-                                  NULL, ctxt, &def->space_soft_limit,
-                                  1, ULLONG_MAX, false) < 0)
+    if (virParseScaledValue("./space_soft_limit[1]",
+                            NULL, ctxt, &def->space_soft_limit,
+                            1, ULLONG_MAX, false) < 0)
         goto error;
 
     cur = node->children;
@@ -14946,8 +14877,8 @@
         goto cleanup;
     }
 
-    if (virDomainParseScaledValue("./size[1]", NULL, ctxt,
-                                  &def->size, 1, ULLONG_MAX, false) < 0)
+    if (virParseScaledValue("./size[1]", NULL, ctxt,
+                            &def->size, 1, ULLONG_MAX, false) < 0)
         goto cleanup;
 
     if ((server = virXPathNode("./server[1]", ctxt))) {
@@ -19327,9 +19258,9 @@
         return -1;
     }
 
-    if (virDomainParseScaledValue("./@size", "./@unit",
-                                  ctxt, &size, 1024,
-                                  ULLONG_MAX, true) < 0)
+    if (virParseScaledValue("./@size", "./@unit",
+                             ctxt, &size, 1024,
+                             ULLONG_MAX, true) < 0)
         return -1;
 
     if (virResctrlAllocSetCacheSize(alloc, level, type, cache, size) < 0)
@@ -20436,13 +20367,13 @@
                 VIR_FREE(tmp);
             }
 
-            if (virDomainParseScaledValue("./features/hpt/maxpagesize",
-                                          NULL,
-                                          ctxt,
-                                          &def->hpt_maxpagesize,
-                                          1024,
-                                          ULLONG_MAX,
-                                          false) < 0) {
+            if (virParseScaledValue("./features/hpt/maxpagesize",
+                                    NULL,
+                                    ctxt,
+                                    &def->hpt_maxpagesize,
+                                    1024,
+                                    ULLONG_MAX,
+                                    false) < 0) {
                 virReportError(VIR_ERR_CONFIG_UNSUPPORTED,
                                "%s",
                                _("Unable to parse HPT maxpagesize setting"));
@@ -20668,13 +20599,13 @@
     }
 
     if (def->features[VIR_DOMAIN_FEATURE_SMM] == VIR_TRISTATE_SWITCH_ON) {
-        int rv = virDomainParseScaledValue("string(./features/smm/tseg)",
-                                           "string(./features/smm/tseg/@unit)",
-                                           ctxt,
-                                           &def->tseg_size,
-                                           1024 * 1024, /* Defaults to mebibytes */
-                                           ULLONG_MAX,
-                                           false);
+        int rv = virParseScaledValue("string(./features/smm/tseg)",
+                                     "string(./features/smm/tseg/@unit)",
+                                     ctxt,
+                                     &def->tseg_size,
+                                     1024 * 1024, /* Defaults to mebibytes */
+                                     ULLONG_MAX,
+                                     false);
         if (rv < 0)
             goto error;
         def->tseg_specified = rv;
--- a/src/libvirt_private.syms
+++ b/src/libvirt_private.syms
@@ -3439,6 +3439,7 @@
 
 
 # util/virxml.h
+virParseScaledValue;
 virXMLCheckIllegalChars;
 virXMLChildElementCount;
 virXMLExtractNamespaceXML;
--- a/src/util/virxml.c
+++ b/src/util/virxml.c
@@ -33,6 +33,7 @@
 #include "viralloc.h"
 #include "virfile.h"
 #include "virstring.h"
+#include "virutil.h"
 
 #define VIR_FROM_THIS VIR_FROM_XML
 
@@ -1433,3 +1434,74 @@
 
     return 0;
 }
+
+
+/**
+ * virParseScaledValue:
+ * @xpath: XPath to memory amount
+ * @units_xpath: XPath to units attribute
+ * @ctxt: XPath context
+ * @val: scaled value is stored here
+ * @scale: default scale for @val
+ * @max: maximal @val allowed
+ * @required: is the value required?
+ *
+ * Parse a value located at @xpath within @ctxt, and store the
+ * result into @val. The value is scaled by units located at
+ * @units_xpath (or the 'unit' attribute under @xpath if
+ * @units_xpath is NULL). If units are not present, the default
+ * @scale is used. If @required is set, then the value must
+ * exist; otherwise, the value is optional. The resulting value
+ * is in bytes.
+ *
+ * Returns 1 on success,
+ *         0 if the value was not present and !@required,
+ *         -1 on failure after issuing error.
+ */
+int
+virParseScaledValue(const char *xpath,
+                    const char *units_xpath,
+                    xmlXPathContextPtr ctxt,
+                    unsigned long long *val,
+                    unsigned long long scale,
+                    unsigned long long max,
+                    bool required)
+{
+    unsigned long long bytes;
+    g_autofree char *xpath_full = NULL;
+    g_autofree char *unit = NULL;
+    g_autofree char *bytes_str = NULL;
+
+    *val = 0;
+    xpath_full = g_strdup_printf("string(%s)", xpath);
+
+    bytes_str = virXPathString(xpath_full, ctxt);
+    if (!bytes_str) {
+        if (!required)
+            return 0;
+        virReportError(VIR_ERR_XML_ERROR,
+                       _("missing element or attribute '%s'"),
+                       xpath);
+        return -1;
+    }
+    VIR_FREE(xpath_full);
+
+    if (virStrToLong_ullp(bytes_str, NULL, 10, &bytes) < 0) {
+        virReportError(VIR_ERR_XML_ERROR,
+                       _("Invalid value '%s' for element or attribute '%s'"),
+                       bytes_str, xpath);
+        return -1;
+    }
+
+    if (units_xpath)
+         xpath_full = g_strdup_printf("string(%s)", units_xpath);
+    else
+         xpath_full = g_strdup_printf("string(%s/@unit)", xpath);
+    unit = virXPathString(xpath_full, ctxt);
+
+    if (virScaleInteger(&bytes, unit, scale, max) < 0)
+        return -1;
+
+    *val = bytes;
+    return 1;
+}
--- a/src/util/virxml.h
+++ b/src/util/virxml.h
@@ -269,3 +269,11 @@
 int
 virXMLNamespaceRegister(xmlXPathContextPtr ctxt,
                         virXMLNamespace const *ns);
+
+int virParseScaledValue(const char *xpath,
+                        const char *units_xpath,
+                        xmlXPathContextPtr ctxt,
+                        unsigned long long *val,
+                        unsigned long long scale,
+                        unsigned long long max,
+                        bool required);
